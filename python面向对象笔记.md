### 面向对象

1.面向过程

- 把完成某一个需求的`所有步骤` `从头到尾`逐步实现
- 将某些**功能独立**的代码**封装**成一个又一个的**函数**
- 顺序调用**不同函数**

2.面向对象

- 确定**职责（方法）**
- 根据**职责**确定不同的**对象**，在**对象**内部封装不同的**方法**
- 顺序地让**不同的对象**调用**不同的方法**

> **面向对象**是**更大**的**封装**，根据**职责**在**一个对象中封装多个方法**

 

### 类和对象

1.**类**和**对象**是**面向对象编程**的**核心概念**

2.类

- **类**是对一群具有**相同特征**或**行为**的事物的一个统称，是抽象的，**不能直接使用**
  - **特征**被称为**属性**
  - **行为**被称为**方法**

- **类**是**模板**，负责**创建对象**

3.对象

- **对象**是由**类创建出的一个具体存在**，可以直接使用
- **对象**拥有**类**中定义的**属性**、**方法**

> 先有**类**，再有**对象**

4.类与对象的关系

- **类**只有一个，而**对象**可以有很多个，**不同对象**之间的**属性**可以各不相同
- **类**中定义了什么**属性和方法**，**对象**中就有什么属性和方法，**不可能多或少**

5.类的设计

- **类名** 这类事物的名字，**满足大驼峰命名法**(每个单词首字母大写/之间没有下划线)
- **属性** 这类事物具有什么样的特征
- **方法**这类事物具有什么样的行为

> **名词提炼**是**类**，**对象的特征描述**可以定义成**属性**，**对象具有的行为**可以定义成**方法**



### 面向对象基础语法

1.`dir`函数传入**标识符、数据**，可以查看对象内**所有属性和方法**

- **变量、数据、函数**都是对象

> `__方法名__`格式的方法是`python`提供的**内置方法/属性** 

2.定义简单的类

```python
class  类名:
    def 方法1(self, 参数列表)：
    	pass  
```

- **方法**的定义格式与**函数**一样
- **区别**是第一个参数必须是`self`

3.创建对象

- 语法格式：`变量对象 = 类名()`
- 使用类**创建对象**之后，变量中仍然记录的是**对象在内存中的地址**，即变量**引用了新建的对象**
  - 使用`print`能够输出这个变量**引用的对象**是由**哪一个类创建的对象**，以及**在内存中的地址**

- 使用**类再创建的对象**是**不同**的对象

4.方法中的self参数

- 在**类外部的代码**可以通过`.`增加属性

> 不推荐使用，对象属性的封装应该封装在类的内部

- 哪一个对象调用的方法，`self`就是哪一个对象的引用
- **在方法内部**，可以通过`self.`**访问对象的属性**，也可以通过`self.`**调用其他的对象方法**

5.初始化方法

- 当使用`类名()`创建对象时，会**自动**执行以下操作
  - 为对象在内存中**分配空间**--创建对象
  - 为对象的属性**设置初始值**--初始化方法(`__init__`)

- 在`__init__`方法内部使用`self.属性名 = 属性的初始值`就可以**定义属性**(避免在类外定义)
- 把希望设置的属性值，定义成`__init__`方法的参数，在创建对象时，使用`类名(属性1，属性2...)调用`

6.`__del__`方法

- 当一个**对象被从内存中销毁**前，会**自动调用**`__del__`方法

7.`__str__`方法

- 使用`print`输出**对象变量**时，能够打印**自定义的内容**
- `__str__`方法必须返回一个字符串

### 面向对象封装

1.**封装**

- **封装**是面向对象编程的一大特点
- 面向对象编程的**第一步**--将**属性**和**方法 封装**到一个抽象的**类**中
- **外界**使用**类**创建**对象**，然后**让对象调用方法**

> 在**对象的方法内部**，可以直接访问**对象的属性**

> **同一类** 创建的**多个对象**之间，**属性**互不干扰

2.**被使用的类**，通常应该先开发

> python能够自动将一对括号内代码连接在一起(适合长语句换行)

### 私有属性和私有方法

1.应用场景：**对象**的**某些属性或方法**只希望**在对象内部使用**

2.定义方式：在**属性名或者方法名前**增加**两个下划线**

3.伪私有属性和方法

> python中没有真正意义的私有

- 私有属性和方法可以通过`对象._类名__名称`访问到(不推荐)

### 继承

面向对象三大特性：

- **封装**  将**属性**和**方法** **封装**到一个抽象的**类**中

- **继承** **实现代码的重用**，相同的代码不需要重复的编写

- **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码灵活度**

### 单继承

1.继承的语法

- **子类**继承自**父类**
- **子类**应该根据**职责**，封装**子类特有的属性和方法**

```python
class 类名(父类):
    pass
```

2.继承具有传递性

### 方法的重写

1.当**父类**的方法不能满足子类的需要，可以对方法进行**重写**

2.**重写**包括**覆盖**与**扩展**

3.覆盖：在**子类**中定义一个**和父类同名的方法并实现**

4.扩展：

- 在**子类**中重写父类的方法
- 在需要的位置(在子类的对应方法内)使用`super().父类方法`，来调用父类方法的执行

关于`super`

- 在python中`super`是一个**特殊的类**
- `super()`就是使用`super`类创建出来的对象
- **最常**使用场景就是，**重写父类方法时**，调用**父类中封装方法的实现**

5.`父类.方法(self)`也可以调用父类方法，但不推荐

### 多继承

1.**子类**可以拥有**多个父类**，并且具有**所有父类**的**属性**和**方法**

2.

``` python
class  子类名(父类名1,父类名2,...):
    pass
```

3.如果**不同的父类**中存在**同名的方法**，应该**尽量避免**使用多继承

4.`MRO`

- `python`中针对**类**，提供了一个**内置属性**`__mro__`可以查看**方法**搜索顺序(`类名.__mro__`调用）
- 在搜索方法时，按`__mro__`的输出结果**从左到右**的顺序查找的
- 如果在当前类中**找到方法，就直接执行，不再搜索**

5.新式类与经典类

- **新式类**：以`object`为基类的类，**推荐使用**，(`dir(对象)`可以查看object方法)
- **经典类**：不以`object`为基类的类，不推荐使用

> **新式类**和**经典类**在多继承时---**会影响到方法的搜索顺序**

定义类时，最好统一继承自`object`类，保证代码在python 2环境下也能运行

### 多态

1.不同的**子类对象**调用相同的**父类方法**，产生不同的执行结果

- 以**继承**和**重写父类方法**为前提
- 是调用方法的技巧，**不会影响到类的内部设计**

> 实现：传入函数的参数为对象，而对象属于不同类，就会产生不同的执行效果

### 类属性

1.实例:对象创建后，**内存**中就有了一个对象**实实在在**的存在--**实例**

- **每一个对象**都有自己**独立的内存空间**，**保存各自不同的属性**
- **多个对象的方法，在内存中只有一份**，在调用方法时，**需要把对象的引用**传递到方法内部

2.类是一个特殊的对象

> python中**一切皆对象**
>
> - `class  AAA():`属于类对象
> - `obj1 = AAA():`属于实例对象

- 程序运行时，**类**同样**会被加载到内存**
- 程序运行时，**类对象**在内存中**只有一份**，使用**一个类**可以创建出**很多个对象实例**
- 除了封装**实例**的**属性**和**方法**外，**类对象**还可以拥有自己的**属性**和**方法**
- 通过`类名.`的方式可以**访问类的属性**或者**调用类的方法**

3.类属性和实例属性

- **类属性**就是给**类对象**中定义的**属性**
- 通常用来记录**与这个类相关**的特征
- **类属性**不会用于记录**具体对象的特征**

> 示例需求：类创建了多少个工具对象

4.属性的获取机制--**向上查找机制**

- 首先在对象内部**查找对象属性**，没有就向上**寻找类属性**
- 不推荐使用**对象.类属性**访问**类属性**

> 如果使用`对象.类属性 = 值`赋值语句，只会**给对象添加一个属性**，而不会影响到**类属性的值**

### 类方法

1.语法

```python
@classmethod
def 类方法名(cls):
    pass
```

2.解释

- 类方法需要用修饰器`@classmethod`来标识，**告诉解释器这是一个类方法**
- 类方法的**第一个参数**应该`cls`
  - 由**哪一类**调用的方法，方法内的`cls`就是**哪一类的引用**
  - 使用其他名称也可以，不过习惯使用`cls`
- 通过**类名**，调用**类方法**，**调用方法时**，不需要传递`cls`参数
- **在方法内部**
  - 可以通过`cls.`**访问类的属性**
  - 也可以通过`cls.`**调用其他类方法**

### 静态方法

1.在开发时，如果需要在**类**中封装一个方法，这个方法：

- 既**不需要**访问**实例属性**或者调用**实例方法**
- 也**不需要**访问**类属性**或者调用**类方法**

可以把这个方法封装成**静态方法**

判断：如果不需要传入类，也不需要传入实例，就是一个静态方法

2.语法：

```python
@staticmethod
def 静态方法名():
    pass
```

3.通过`类名.静态方法()`调用--不需要创建实例对象

### 方法案例综合

1.**实例方法**--方法内部需要访问**实例属性**

2.**类方法**--方法内部**只**需要访问**类属性**

3.**静态方法**--方法内部，不需要访问**实例属性**和**类属性**

### 单例

1.单例设计模式

- 设计模式
  - **设计模式**是**前人工作的总结和提炼**，通常，被人们广泛流传的设计模式都是针对**某一特定问题**的成熟解决方案
  - 使用**设计模式**是为了可重用代码、让代码更容易被理解、保证代码可靠性
- 单例设计模式
  - **目的**--让**类**创建的对象，在系统中**只有唯一一个实例**
  - 每一次执行`类名()`返回的对象，**内存地址是相同的**

2.`__new__`方法

- 使用**`类名()`**创建对象时，python的解释器**首先**会调用`__new__`方法为对象**分配空间**
- `__new__`是一个由`object`基类提供的**内置静态方法**，主要作用有：
  - 在内存中为对象**分配空间**
  - **返回**对象的引用
- python的解释器获得对象的**引用**后，将引用作为**第一个参数**，传递给`__init__`方法

3.重写`__new__`方法

> 重写`__new__`方法的代码非常固定

- 重写`__new__`方法一定要`return  super().__new__(cls)`

> 此时父类`object`的方法已经不起作用

- 否则python解释器**得不到**分配了空间的**对象引用，就不会调用对象初始化方法**
- `__new__`是一个静态方法，在调用时需要**主动传递**`cls`参数

